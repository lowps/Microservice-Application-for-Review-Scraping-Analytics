#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys

"""
Load environment variables dynamically based on the DJANGO_ENV variable.

Setting DJANGO_ENV for Environment Configuration

This environment variable controls which .env file your Django project loads 
(e.g., '.env.dev' or '.env.prod'). It should be set **outside** your Python code,
typically in the terminal or your OS environment, before starting your app.

How to set DJANGO_ENV in your terminal (Mac/Linux):

    # For development environment (.env.dev)
    export DJANGO_ENV=dev

    # For production environment (.env.prod)
    export DJANGO_ENV=prod
    OR
    It is set in the Dockerfile or docker-compose file, which configures the entire container environment.
        Therefore, it becomes the default environment variable for the container.

How to check if it's set:

    echo $DJANGO_ENV

Behavior:
---------
1. Reads `DJANGO_ENV` from the existing environment.
    Your __init__.py reads DJANGO_ENV from the current environment 
    (not from the .env.prod file yet, because that file only gets loaded after DJANGO_ENV is read).
2. If `DJANGO_ENV` is not defined, defaults to `"dev"`.
3. Constructs the path to the `.env` file accordingly, e.g., `.env.dev` or `.env.prod`.
4. Loads the environment variables from that `.env` file into the current process.

Usage:
------
- Set `DJANGO_ENV=prod` in your environment (or in your `.env.prod`) to load `.env.prod`.
- Omit or set `DJANGO_ENV=dev` (or leave unset) to load `.env.dev`.
- This allows a single entry point to select configuration dynamically.

Usage example:

    #No dollar sign ($) on the left-hand side when setting. Using $ will: This tries to expand the variable name, not assign it.
    export DJANGO_ENV=prod 
    or
    export DJANGO_ENV=dev
    python manage.py runserver

This runs your Django app with the production environment variables loaded.

Note:
-----
- Ensure `.env.dev` and `.env.prod` are located in the `i_app/` directory, sibling to this file.
- This relies on `python-dotenv`'s `load_dotenv` function.
"""


"""
Load environment variables from the appropriate .env file before Django initialization.

This ensures Django picks up the correct settings module (e.g., production vs. development)
**before** it attempts to load settings. It relies on a custom environment variable
called DJANGO_ENV to determine which file to load (e.g., .env.dev, .env.prod).

Why this is needed:
-------------------
• Django checks the DJANGO_SETTINGS_MODULE very early — before your settings files load.
• .env files are not shell scripts and do NOT export variables globally.
• `load_dotenv()` makes the environment variables available to Python at runtime,
  but ONLY if called early enough (before settings are evaluated).

How it works:
-------------
1. Reads DJANGO_ENV from the shell (default = "dev")
2. Constructs a path to `.env.{DJANGO_ENV}`
3. Loads the file and injects its contents into os.environ

Example:
--------
# Terminal
$ export DJANGO_ENV=prod
$ python manage.py runserver  # Will now load .env.prod before settings

Notes:
------
• This only affects Pythons runtime env — it wont show up via `echo $VARNAME`
• To export env vars globally in the shell, use:
    $ set -a && source .env.prod && set +a

• You MUST call load_dotenv() before any Django imports or Django setting checks
"""


def main():
    """
    Django Management Command Entry Point with Environment Configuration
    ----------------------------------------------------------------
    This only sets the default if DJANGO_SETTINGS_MODULE is not already set.
    If your Docker Compose (.env.prod) or shell explicitly sets DJANGO_SETTINGS_MODULE, that takes priority.

    Key Responsibilities:
    1. Sets the default Django settings module (app.settings.local) if not specified
    2. Provides clear error messaging for Django dependency issues
    3. Executes command-line management commands

    Environment Control Hierarchy:
    ----------------------------
    The active settings module is determined by this precedence:
    1. Explicit ENV variable (Highest priority)
       $ export DJANGO_SETTINGS_MODULE=app.settings.production
    2. Command-line argument (via --settings flag)
       $ python manage.py runserver --settings=app.settings.staging
    3. This setdefault() call (Fallback)

    Usage Guidance:
    --------------
    • Local Development:
      - Uses default app.settings.local
      - No environment configuration needed

    • Production Deployment:
      DO NOT edit this file - instead:
      - Set environment variable:
        $ export DJANGO_SETTINGS_MODULE=app.settings.production
      - Or use Gunicorn/Nginx configuration

    Safety Checks:
    -------------
    • Validates Django is importable before execution
    • Preserves existing environment settings if set

    Example Invocations:
    -------------------
    $ python manage.py runserver               # Uses local settings
    $ python manage.py shell --settings=app.settings.testing  # Override temporarily
    """
    from pathlib import Path
    from dotenv import load_dotenv

    env_type = os.getenv("DJANGO_ENV", "dev")
    env_path = Path(__file__).resolve().parent / "i_app" / f".env.{env_type}"
    load_dotenv(dotenv_path=env_path)

    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "app.settings.local")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()

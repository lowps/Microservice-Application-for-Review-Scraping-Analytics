import os
from dotenv import load_dotenv, find_dotenv
from pathlib import Path


def get_secret(secret_id, backup=None):
    """
    Retrieve a secret from $ENV VARIABLE with an optional fallback.

    Safely fetches the value of an PYTHON ENVIRONMENT VARIABLE loaded via `os.getenv()`.
    If the variable is not set, returns a given backup value.

    If function can't locate enviornment variables then consider using 'find_dotenv()' & 'load_dotenv()' functions,
    a function provided by python-dotenv library, primarily used to manage enviornment variables
    in python applications. It reads key-value pairs by parsing (reading) a .env file and loads them into the environment,
    making them accessible to your application as if they were set in the operating system's environment.
    Enviornment Variables are loaded into memory by the load_dotenv() call.
        -Note: if you use "find_dotenv()", by default it looks for ".env" as the file name. If your file is named
               something else then specify that name. Ex: find_dotenv(".env.dev")

    The enviornment variables become available to your Pythons script and any child processes it spawns. You
    can then access them variables using pythongs built-in 'os.getenv()', but its recommended to use this function,
    "get_secret()" because it prevents silent errors and much comprehensive troubleshooting.

    Args:
        secret_id (str): Name of the PYTHON ENVIRONMENT VARIABLE to retrieve (ex: "DB_PASSWORD").
        backup (Any, optional): Fallback value if the environment variable is not set.
            Defaults to `None`.

    Returns:
        Any: The value of the environment variable if it exists, otherwise the backup value.

    Example:
        1) With .env file containing: SECRET_KEY='mykey123'
        2) get_secret("SECRET_KEY", backup="default_key")
            - Returns the python environment variable value, in this case 'mykey123'

    Note:
        - Requires environment variables to be pre-loaded (e.g., via `python-dotenv`).
        - Never hardcode secrets in the backup value for production use.
    """
    value = os.getenv(secret_id, backup)
    if value is None:
        raise ValueError(f"Missing required secret: {secret_id}")
    return value


"""
Django Settings Loader (Dynamic Environment Handler)
--------------------------------------------------

This module dynamically loads the appropriate settings based on the 
DJANGO_SETTINGS_MODULE environment variable. The loading follows this logic:

1. Checks enviornment variable DJANGO_SETTINGS_MODULE (default: 'app.settings.local')
2. Imports the corresponding environment-specific settings
3. Falls back safely if module doesn't exist
4. Provides debug output about which settings were loaded

IMPORTANT CONFIGURATION NOTES:
- Primary control point: Two options for primary control point. 
   1) Bash Shell option: First Run one of these in your shell before 
    starting the wsgi server command (ex: manage.py, gunicorn).
    EXAMPLE for local development: source ./env.switch.sh dev
    EXAMPLE for production development: ./env.switch.sh prod

    OR

    2) Python process (manage.py) option: Go to 'manage.py' file and within the code line
    "os.environ.setdefault("DJANGO_SETTINGS_MODULE", "app.settings.production")" edit the second
    parameter to your desired settings: "app.settings.production" or "app.settings.local"

- Production control: Set via environment variables or:
  - Gunicorn: Use --settings flag or ENV var
  - Nginx: Pass through with uwsgi_param/environment directives

DO NOT edit this file to change environments - instead as primary control point:
- Refer to bash file: env.switch.sh or manage.py
"""
# settings_mode = os.getenv("DJANGO_SETTINGS_MODULE", "app.settings.local")

# if settings_mode == "app.settings.local":
#     try:
#         from .local import *
#     except ImportError:
#         pass
#     finally:
#         print(f".local settings loaded | Active: {settings_mode}")
# elif settings_mode == "app.settings.production":
#     try:
#         from .production import *
#     except ImportError:
#         pass
#     finally:
#         print(f".production settings loaded | Active: {settings_mode}")
# else:
#     raise ImportError(f"Unknown settings module: {settings_mode}")

if __name__ == "__main__":
    pass
